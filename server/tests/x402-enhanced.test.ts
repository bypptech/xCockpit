import { describe, it, expect, beforeEach, afterEach, jest } from '@jest/globals';\nimport { BlockchainVerifier } from '../services/blockchain-verifier';\nimport { orderManager, OrderManager } from '../services/order-manager';\nimport { signatureVerifier, SignatureVerifier } from '../services/signature-verifier';\nimport { X402Service } from '../services/x402';\n\n// Mock ethers\njest.mock('ethers', () => ({\n  ethers: {\n    JsonRpcProvider: jest.fn().mockImplementation(() => ({\n      getTransactionReceipt: jest.fn(),\n      getBlockNumber: jest.fn(),\n    })),\n    Contract: jest.fn().mockImplementation(() => ({\n      interface: {\n        parseLog: jest.fn(),\n      },\n      target: '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913',\n      balanceOf: jest.fn(),\n    })),\n    parseUnits: jest.fn((amount, decimals) => BigInt(parseFloat(amount) * Math.pow(10, decimals))),\n    formatUnits: jest.fn((amount, decimals) => (Number(amount) / Math.pow(10, decimals)).toString()),\n  },\n}));\n\ndescribe('Enhanced x402 Implementation', () => {\n  let testOrderManager: OrderManager;\n  let testSignatureVerifier: SignatureVerifier;\n  \n  beforeEach(() => {\n    testOrderManager = new OrderManager();\n    testSignatureVerifier = new SignatureVerifier('test-secret-key');\n    \n    // Reset environment\n    process.env.ENHANCED_X402 = 'true';\n    process.env.NETWORK = 'sepolia';\n  });\n  \n  afterEach(() => {\n    testOrderManager.reset();\n    testOrderManager.stopCleanup();\n    jest.clearAllMocks();\n  });\n  \n  describe('OrderManager', () => {\n    it('should generate valid order with nonce', () => {\n      const { orderId, nonce, nonceExp } = testOrderManager.generateOrder(5);\n      \n      expect(orderId).toMatch(/^ord_[0-9a-f]{32}$/);\n      expect(nonce).toMatch(/^nx_[0-9a-f]{32}$/);\n      expect(new Date(nonceExp)).toBeInstanceOf(Date);\n      expect(new Date(nonceExp) > new Date()).toBe(true);\n    });\n    \n    it('should validate order correctly', () => {\n      const { orderId, nonce } = testOrderManager.generateOrder(5);\n      \n      const validation = testOrderManager.validateOrder(orderId, nonce);\n      expect(validation.valid).toBe(true);\n      expect(validation.order).toBeDefined();\n      expect(validation.order!.orderId).toBe(orderId);\n    });\n    \n    it('should reject invalid nonce', () => {\n      const { orderId } = testOrderManager.generateOrder(5);\n      \n      const validation = testOrderManager.validateOrder(orderId, 'invalid-nonce');\n      expect(validation.valid).toBe(false);\n      expect(validation.error).toBe('Invalid nonce');\n    });\n    \n    it('should reject expired orders', () => {\n      const { orderId, nonce } = testOrderManager.generateOrder(0); // Expires immediately\n      \n      // Wait for expiration\n      setTimeout(() => {\n        const validation = testOrderManager.validateOrder(orderId, nonce);\n        expect(validation.valid).toBe(false);\n        expect(validation.error).toBe('Order expired');\n      }, 100);\n    });\n    \n    it('should consume order only once', () => {\n      const { orderId, nonce } = testOrderManager.generateOrder(5);\n      \n      const firstConsume = testOrderManager.consumeOrder(orderId, nonce, 'test-tx-hash');\n      expect(firstConsume).toBe(true);\n      \n      const secondConsume = testOrderManager.consumeOrder(orderId, nonce, 'test-tx-hash-2');\n      expect(secondConsume).toBe(false);\n    });\n    \n    it('should cleanup expired orders', () => {\n      testOrderManager.generateOrder(0); // Create expired order\n      testOrderManager.generateOrder(0); // Create another expired order\n      testOrderManager.generateOrder(60); // Create valid order\n      \n      setTimeout(() => {\n        const cleaned = testOrderManager.cleanupExpiredOrders();\n        expect(cleaned).toBeGreaterThan(0);\n        \n        const stats = testOrderManager.getStats();\n        expect(stats.expiredOrders).toBe(0);\n      }, 100);\n    });\n  });\n  \n  describe('SignatureVerifier', () => {\n    const testRequirements = {\n      scheme: 'x402-exact',\n      chain: 'eip155:8453',\n      token: 'erc20:0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913',\n      amount: '12.34',\n      currency: 'USDC',\n      to: '0x1c7d4b196cb0c7b01d743fbc6116a902379c7238',\n      minConfirmations: 2,\n      orderId: 'ord_test123',\n      nonce: 'nx_test456',\n      nonceExp: '2025-09-01T09:05:00Z',\n    };\n    \n    it('should sign and verify payment requirements', () => {\n      const { requirementsHeader, signature } = testSignatureVerifier.signPaymentRequirements(testRequirements);\n      \n      expect(requirementsHeader).toContain('scheme=\"x402-exact\"');\n      expect(requirementsHeader).toContain('amount=\"12.34\"');\n      expect(signature).toMatch(/^v1=[0-9a-f]+$/);\n      \n      const isValid = testSignatureVerifier.verifyPaymentRequirements(requirementsHeader, signature);\n      expect(isValid).toBe(true);\n    });\n    \n    it('should reject tampered requirements', () => {\n      const { requirementsHeader, signature } = testSignatureVerifier.signPaymentRequirements(testRequirements);\n      \n      const tamperedHeader = requirementsHeader.replace('12.34', '99.99');\n      const isValid = testSignatureVerifier.verifyPaymentRequirements(tamperedHeader, signature);\n      expect(isValid).toBe(false);\n    });\n    \n    it('should parse requirements header correctly', () => {\n      const { requirementsHeader } = testSignatureVerifier.signPaymentRequirements(testRequirements);\n      \n      const parsed = testSignatureVerifier.parseRequirementsHeader(requirementsHeader);\n      expect(parsed).toBeDefined();\n      expect(parsed!.scheme).toBe('x402-exact');\n      expect(parsed!.amount).toBe('12.34');\n      expect(parsed!.orderId).toBe('ord_test123');\n    });\n    \n    it('should generate valid payment state header', () => {\n      const stateHeader = testSignatureVerifier.generatePaymentStateHeader(\n        '0x1234567890abcdef',\n        3,\n        'eip155:8453'\n      );\n      \n      expect(stateHeader).toBe('paid; chain=\"eip155:8453\"; tx_hash=\"0x1234567890abcdef\"; confirmations=\"3\"');\n    });\n  });\n  \n  describe('BlockchainVerifier', () => {\n    let mockProvider: any;\n    let mockContract: any;\n    \n    beforeEach(() => {\n      const { ethers } = require('ethers');\n      mockProvider = {\n        getTransactionReceipt: jest.fn(),\n        getBlockNumber: jest.fn(),\n      };\n      mockContract = {\n        interface: {\n          parseLog: jest.fn(),\n        },\n        target: '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913',\n        balanceOf: jest.fn(),\n      };\n      \n      ethers.JsonRpcProvider.mockImplementation(() => mockProvider);\n      ethers.Contract.mockImplementation(() => mockContract);\n    });\n    \n    it('should verify successful USDC transfer', async () => {\n      const receipt = {\n        status: 1,\n        blockNumber: 1000,\n        logs: [\n          {\n            address: '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913',\n            topics: ['0x...'],\n            data: '0x...',\n          },\n        ],\n      };\n      \n      const transferEvent = {\n        name: 'Transfer',\n        args: {\n          to: '0x1c7d4b196cb0c7b01d743fbc6116a902379c7238',\n          value: BigInt(12340000), // 12.34 USDC (6 decimals)\n        },\n      };\n      \n      mockProvider.getTransactionReceipt.mockResolvedValue(receipt);\n      mockProvider.getBlockNumber.mockResolvedValue(1003);\n      mockContract.interface.parseLog.mockReturnValue(transferEvent);\n      \n      const verifier = new BlockchainVerifier('sepolia');\n      const result = await verifier.verifyUSDCTransfer({\n        txHash: '0x1234567890abcdef',\n        expectedTo: '0x1c7d4b196cb0c7b01d743fbc6116a902379c7238',\n        minAmount: '12.34',\n        minConfirmations: 2,\n      });\n      \n      expect(result.verified).toBe(true);\n      expect(result.confirmations).toBe(3);\n      expect(result.actualAmount).toBe('12.34');\n    });\n    \n    it('should reject transaction with insufficient confirmations', async () => {\n      const receipt = {\n        status: 1,\n        blockNumber: 1000,\n        logs: [],\n      };\n      \n      mockProvider.getTransactionReceipt.mockResolvedValue(receipt);\n      mockProvider.getBlockNumber.mockResolvedValue(1001); // Only 1 confirmation\n      \n      const verifier = new BlockchainVerifier('sepolia');\n      const result = await verifier.verifyUSDCTransfer({\n        txHash: '0x1234567890abcdef',\n        expectedTo: '0x1c7d4b196cb0c7b01d743fbc6116a902379c7238',\n        minAmount: '12.34',\n        minConfirmations: 2,\n      });\n      \n      expect(result.verified).toBe(false);\n      expect(result.error).toContain('Insufficient confirmations');\n    });\n  });\n  \n  describe('X402Service Integration', () => {\n    it('should create enhanced 402 response', () => {\n      const response = X402Service.create402Response('ESP32_001', 'dispense', 5);\n      \n      expect(response.status).toBe(402);\n      expect(response.headers['X-Payment-Requirements']).toBeDefined();\n      expect(response.headers['X-Payment-Signature']).toBeDefined();\n      expect(response.body.orderId).toBeDefined();\n      expect(response.body.nonce).toBeDefined();\n    });\n    \n    it('should calculate correct device pricing', () => {\n      const price001 = X402Service.calculateDevicePrice('ESP32_001', 'dispense');\n      const price002 = X402Service.calculateDevicePrice('ESP32_002', 'dispense');\n      \n      expect(price001).toBe('0.010'); // Gacha #001のfeeが$0.01 USDCに設定されている\n      expect(price002).toBe('0.005'); // Gacha #002のfeeが$0.005USDCに設定されている\n    });\n    \n    it('should verify payment with enhanced logic when enabled', async () => {\n      // Mock blockchain verification to succeed\n      const mockVerifier = {\n        verifyUSDCTransfer: jest.fn().mockResolvedValue({\n          verified: true,\n          confirmations: 3,\n          actualAmount: '0.01',\n          blockNumber: 1000,\n        }),\n      };\n      \n      // Override static property\n      (X402Service as any).blockchainVerifier = mockVerifier;\n      \n      const { orderId, nonce } = testOrderManager.generateOrder(5);\n      \n      const payment = {\n        amount: '0.01',\n        currency: 'USDC',\n        network: 'eip155:84532',\n        recipient: '0x1c7d4b196cb0c7b01d743fbc6116a902379c7238',\n        metadata: {\n          orderId,\n          nonce,\n          txHash: '0x1234567890abcdef',\n        },\n      };\n      \n      const result = await X402Service.verifyPayment(payment);\n      \n      expect(result.verified).toBe(true);\n      expect(result.confirmations).toBe(3);\n      expect(mockVerifier.verifyUSDCTransfer).toHaveBeenCalled();\n    });\n    \n    it('should fallback to basic verification when enhanced mode disabled', async () => {\n      process.env.ENHANCED_X402 = 'false';\n      \n      const payment = {\n        amount: '0.01',\n        currency: 'USDC',\n        network: 'eip155:84532',\n        recipient: '0x1c7d4b196cb0c7b01d743fbc6116a902379c7238',\n        metadata: {\n          txHash: '0x1234567890abcdef',\n        },\n      };\n      \n      const result = await X402Service.verifyPayment(payment);\n      \n      expect(result.verified).toBe(true);\n    });\n  });\n  \n  describe('Security Tests', () => {\n    it('should prevent replay attacks', () => {\n      const { orderId, nonce } = testOrderManager.generateOrder(5);\n      \n      // First use should succeed\n      const firstUse = testOrderManager.consumeOrder(orderId, nonce, 'tx1');\n      expect(firstUse).toBe(true);\n      \n      // Second use should fail\n      const secondUse = testOrderManager.consumeOrder(orderId, nonce, 'tx2');\n      expect(secondUse).toBe(false);\n    });\n    \n    it('should prevent signature tampering', () => {\n      const requirements = {\n        scheme: 'x402-exact',\n        chain: 'eip155:8453',\n        token: 'erc20:0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913',\n        amount: '1.00',\n        currency: 'USDC',\n        to: '0x1c7d4b196cb0c7b01d743fbc6116a902379c7238',\n        minConfirmations: 0,\n        orderId: 'ord_test',\n        nonce: 'nx_test',\n        nonceExp: '2025-09-01T09:05:00Z',\n      };\n      \n      const { requirementsHeader, signature } = testSignatureVerifier.signPaymentRequirements(requirements);\n      \n      // Tamper with amount\n      const tamperedHeader = requirementsHeader.replace('1.00', '0.01');\n      \n      const isValid = testSignatureVerifier.verifyPaymentRequirements(tamperedHeader, signature);\n      expect(isValid).toBe(false);\n    });\n    \n    it('should handle malformed signature headers', () => {\n      const requirements = {\n        scheme: 'x402-exact',\n        chain: 'eip155:8453',\n        token: 'erc20:0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913',\n        amount: '1.00',\n        currency: 'USDC',\n        to: '0x1c7d4b196cb0c7b01d743fbc6116a902379c7238',\n        minConfirmations: 0,\n        orderId: 'ord_test',\n        nonce: 'nx_test',\n        nonceExp: '2025-09-01T09:05:00Z',\n      };\n      \n      const { requirementsHeader } = testSignatureVerifier.signPaymentRequirements(requirements);\n      \n      // Test invalid signature format\n      const isValid1 = testSignatureVerifier.verifyPaymentRequirements(requirementsHeader, 'invalid-format');\n      expect(isValid1).toBe(false);\n      \n      // Test empty signature\n      const isValid2 = testSignatureVerifier.verifyPaymentRequirements(requirementsHeader, '');\n      expect(isValid2).toBe(false);\n      \n      // Test malformed v1 signature\n      const isValid3 = testSignatureVerifier.verifyPaymentRequirements(requirementsHeader, 'v1=invalid');\n      expect(isValid3).toBe(false);\n    });\n  });\n});